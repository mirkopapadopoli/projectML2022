```{r}
#import library
library(e1071)
library(ggplot2)
library(dplyr)
library(Hmisc)
library(corrplot)
library(caret)
library(plyr)
library(rpart)
library(rattle)
library(neuralnet)
```

```{r}
#import csv
waterquality = read.csv("waterQuality.csv")
```

```{r}
#preprocessing se duplicati e nulli
sum(duplicated(waterquality))
sum(is.na(waterquality))
```

```{r}
#preprocessing pulire dati con '#NUM!'
#ind = which(waterquality == "#NUM!")
#ind
```

```{r}
 
waterquality_pre <- waterquality[!(waterquality$is_safe =="#NUM!"),]
```

```{r}
#conversione variabili
waterquality_pre$ammonia = as.numeric(waterquality_pre$ammonia)
waterquality_pre$is_safe = factor(waterquality_pre$is_safe)
```

```{r}
head(waterquality)
```

```{r}
sapply(waterquality, class)
```


```{r}
describe(waterquality)
```


```{r}
dim(waterquality)
```


```{r}
ggplot(data.frame(waterquality_pre$is_safe), aes(x=waterquality_pre$is_safe)) +
  geom_bar()
```
```{r}
waterquality_pre %>%
  filter( uranium < max(uranium) ) %>%
  ggplot( aes(x=uranium)) +
    geom_density(fill="#69b3a2", color="#e9ecef")
```



```{r}
waterquality %>%
  filter( distance_from_home<max(distance_from_home) ) %>%
  ggplot( aes(x=distance_from_home)) +
    geom_density(fill="#69b3a2", color="#e9ecef", alpha=0.8)
```

```{r}
waterquality %>%
  filter( distance_from_last_transaction<max(distance_from_last_transaction) ) %>%
  ggplot( aes(x=distance_from_last_transaction)) +
    geom_density(fill="#69b3a2", color="#e9ecef", alpha=0.8)
```

```{r}
waterquality %>%
  filter( ratio_to_median_purchase_price<max(ratio_to_median_purchase_price) ) %>%
  ggplot( aes(x=ratio_to_median_purchase_price)) +
    geom_density(fill="#69b3a2", color="#e9ecef", alpha=0.8)
```

```{r}
ggplot(data.frame(waterquality$repeat_retailer), aes(x=waterquality$repeat_retailer)) +
  geom_bar()
```

```{r}
  ggplot(data.frame(waterquality$used_chip), aes(x=waterquality$used_chip)) +
  geom_bar()
```

```{r}
ggplot(data.frame(waterquality$used_pin_number), aes(x=waterquality$used_pin_number)) +
  geom_bar()
```

```{r}
ggplot(data.frame(waterquality$online_order), aes(x=waterquality$online_order)) +
  geom_bar()
```

```{r}
ggplot(data.frame(waterquality$fraud), aes(x=waterquality$fraud)) +
  geom_bar()
```

```{r}
#sistemare ggploot
sub <- subset(waterquality, select = c(distance_from_home, distance_from_last_transaction, ratio_to_median_purchase_price))

waterquality %>%
  filter( ratio_to_median_purchase_price < max(ratio_to_median_purchase_price) ) %>%
  ggplot(sub, aes(x=sub, y=len)) + 
  geom_boxplot()
```

```{r}
describe(waterquality)
```

```{r}
#camviare sizes
sizes <- c(35044,10000)
labels <- c("No Fraud","Fraud")

ggplot(data=NULL, aes(x=labels, y=sizes, fill=labels)) +
  geom_bar(stat="identity") +
  labs(title="What Percentage of Transactions Using Chip and Password are Fraud Transactions?", fill="") +
  theme(legend.position="none")
```

```{r}
#scatter matrix tra var continue
my_cols <- c("#00AFBB", "#E7B800", "#FC4E07")  
pairs(waterquality[,1:3], pch = 19,  cex = 0.5,
      col = my_cols[waterquality$fraud],
      lower.panel=NULL)
```

```{r}
#corr matrix
card.cor = cor(waterquality[,1:3])
corrplot(card.cor)
```

```{r}
#relazione se è frode usando torta
sub.fraud = waterquality[which(waterquality$fraud == 1),]
sub.nrow = nrow(sub.fraud)
for(i in 4:7){
  sub.zero = length(sub.fraud[which(sub.fraud[,i] == 0), i])
  sub.one = sub.nrow - sub.zero
  slices <- c(sub.zero, sub.one)
  lbls <- c("non c'e'", "c'e'")
  pct <- round(slices/sum(slices)*100)
  lbls <- paste(lbls, pct) # add percents to labels
  lbls <- paste(lbls,"%",sep="") # ad % to labels
  pie(slices,labels = lbls, col=rainbow(length(lbls)),
   main=colnames(waterquality)[i])
}
#se c'è stata una frode, sicuramente è perché non c'era il pin
```

```{r}
sub.nofraud = waterquality[which(waterquality$fraud == 0),]
sub.nonrow = nrow(sub.nofraud)
for(i in 4:7){
  sub.zero = length(sub.nofraud[which(sub.nofraud[,i] == 0), i])
  sub.one = sub.nonrow - sub.zero
  slices <- c(sub.zero, sub.one)
  lbls <- c("non c'e'", "c'e'")
  pct <- round(slices/sum(slices)*100)
  lbls <- paste(lbls, pct) # add percents to labels
  lbls <- paste(lbls,"%",sep="") # ad % to labels
  pie(slices,labels = lbls, col=rainbow(length(lbls)),
   main=colnames(waterquality)[i])
}
```

```{r}
quantile.cast <- function(column){
  max = summary(column)[[6]]
  first_q = summary(column)[[2]]
  second_q = summary(column)[[3]]
  third_q = summary(column)[[5]]
  
  q = c(first_q, second_q, third_q, max)
  tmp_col = rep(0, length(column))
  
  for(i in c(1:3)){
    indexes = which(column > q[i] && column <= q[i+1])
    tmp_col[indexes] = i
  }
  
  return(tmp_col)
}
```

```{r}
for(i in (1:3)){
  qc = quantile.cast(waterquality[,i])
  qcf = factor(qc, levels = c(0, 1, 2, 3))
  waterquality[paste(colnames(waterquality)[i],"_d", sep="")] = qcf
}
```

```{r}
split.data = function(data, p = 0.7, s = 1){
set.seed(s)
index = sample(1:dim(data)[1])
train = data[index[1:floor(dim(data)[1] * p)], ]
test = data[index[((ceiling(dim(data)[1] * p)) + 1):dim(data)[1]], ]
return(list(train=train, test=test)) } 
```

```{r}
allset= split.data(waterquality, s = 300)
trainset= allset$train
testset= allset$test
prop.table(table(trainset$fraud))
```

```{r}
set.seed(35)
train.tree = trainset[c(1:8)]
modeltree = rpart(fraud ~ ., 
                  data=train.tree, 
                  method = "class")
```

```{r}
modeltree
```

```{r}
fancyRpartPlot(modeltree)
```

```{r}
test.tree = testset[c(1:7)]
testset$Prediction <- predict(modeltree, test.tree, type = "class")
```

```{r}
confusionmatrix.tree = table(testset$fraud, testset$Prediction)
sum(diag(confusionmatrix.tree))/sum(confusionmatrix.tree)

```

```{r}
printcp(modeltree)
```

```{r}
plotcp(modeltree)
```

```{r}
prunedDecisionTree = prune(modeltree, cp=.02)
```

```{r}
fancyRpartPlot(prunedDecisionTree)
```

```{r}
testset$PredictionPR <- predict(prunedDecisionTree, test.tree, type = "class")
confusionmatrix.prunedtree = table(testset$fraud, testset$PredictionPR)
sum(diag(confusionmatrix.prunedtree))/sum(confusionmatrix.prunedtree)
```

```{r}
network = neuralnet(fraud ~ ., train.tree, hidden=4)
```

```{r}

```
